***整数运算***

1. Java的整数运算遵循四则运算规则，可以使用任意嵌套的小括号;
2. 整数的数值表示不但是精确的，而且整数运算永远是精确的，即使是除法也是精确的，因为两个整数相除只能得到结果的整数部分;
3. 特别注意：整数的除法对于除数为0时运行时将报错，但编译不会报错。

### 溢出
	1. 整数由于存在范围限制，如果计算结果超出了范围，就会产生溢出，而溢出不会出错，却会得到一个奇怪的结果：
		int x = 2147483640;
		int y = 15;
		int sum = x + y;
		System.out.println(sum); // -2147483641

	2. 要解决上面的问题，可以把int换成long类型，由于long可表示的整型范围更大，结果就不会溢出；

	3. 还有一种简写的运算符，即+=，-=，*=，/=，它们的使用方法如下：
		n += 100; // 3409, 相当于 n = n + 100;
		n -= 100; // 3309, 相当于 n = n - 100;

### 自增/自减

	Java还提供了++运算和--运算。
	注意++写在前面和后面计算结果是不同的，++n表示先加1再引用n，n++表示先引用n再加1。不建议把++运算混入到常规运算中。


### 移位运算

	1. 对整数进行移位运算：对整数7左移1位将得到整数14，左移两位将得到整数28；左移29位时，由于最高位变成1，因此结果变成了负数。
		int n = 7;       // 00000000 00000000 00000000 00000111 = 7
		int a = n << 1;  // 00000000 00000000 00000000 00001110 = 14
		int b = n << 2;  // 00000000 00000000 00000000 00011100 = 28
		int c = n << 28; // 01110000 00000000 00000000 00000000 = 1879048192
		int d = n << 29; // 11100000 00000000 00000000 00000000 = -536870912

	2. 类似的，对整数28进行右移，结果如下：
		int n = 7;       // 00000000 00000000 00000000 00000111 = 7
		int a = n >> 1;  // 00000000 00000000 00000000 00000011 = 3
		int b = n >> 2;  // 00000000 00000000 00000000 00000001 = 1
		int c = n >> 3;  // 00000000 00000000 00000000 00000000 = 0

	3. 如果对一个负数进行右移，最高位的1不动，结果仍然是一个负数；
	4. 还有一种无符号的右移运算，使用>>>，它的特点是不管符号位，右移后高位总是补0，因此，对一个负数进行>>>右移，它会变成正数，原因是最高位的1变成了0：
		int n = -536870912;
		int a = n >>> 1;  // 01110000 00000000 00000000 00000000 = 1879048192
		int b = n >>> 2;  // 00111000 00000000 00000000 00000000 = 939524096
		int c = n >>> 29; // 00000000 00000000 00000000 00000111 = 7
		int d = n >>> 31; // 00000000 00000000 00000000 00000001 = 1
	5. 对byte和short类型进行移位时，会首先转换为int再进行位移；
	6. 左移实际上就是不断地×2，右移实际上就是不断地÷2。

### 位运算

	1. 与运算的规则是，必须两个数同时为1，结果才为1：
		n = 0 & 0; // 0
		n = 0 & 1; // 0
		n = 1 & 0; // 0
		n = 1 & 1; // 1

	2. 或运算的规则是，只要任意一个为1，结果就为1：
		n = 0 | 0; // 0
		n = 0 | 1; // 1
		n = 1 | 0; // 1
		n = 1 | 1; // 1

	3. 非运算的规则是，0和1互换：
		n = ~0; // 1
		n = ~1; // 0

	4. 异或运算的规则是，如果两个数不同，结果为1，否则为0：
		n = 0 ^ 0; // 0
		n = 0 ^ 1; // 1
		n = 1 ^ 0; // 1
		n = 1 ^ 1; // 0

### 运算优先级
	1. 运算优先级：（记不住，加括号）
		()
		! ~ ++ --
		* / %
		+ -
		<< >> >>>
		&
		|
		+= -= *= /=

### 类型自动提升与强制转型

	1. 在运算过程中，如果参与运算的两个数类型不一致，那么计算结果为较大类型的整型。例如，short和int计算，结果总是int，原因是short首先自动被转型为int；
		short s = 1234;
		int i = 123456;	
		int x = s + i; // s自动转型为int
		short y = s + i; // 编译错误!

	2. 也可以将结果强制转型，即将大范围的整数转型为小范围的整数。强制转型使用(类型)，例如，将int强制转型为short；要注意，超出范围的强制转型会得到错误的结果，原因是转型时，int的两个高位字节直接被扔掉，仅保留了低位的两个字节；
		int i = 12345;
		short s = (short) i; // 12345


### 小结
	1. 整数运算的结果永远是精确的；
	2. 运算结果会自动提升；
	3. 可以强制转型，但超出范围的强制转型会得到错误的结果；
	4. 应该选择合适范围的整型（int或long），没有必要为了节省内存而使用byte和short进行整数运算。



















